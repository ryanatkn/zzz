import type {Gen} from '@ryanatkn/gro/gen.js';

import {get_innermost_type_name} from '$lib/zod_helpers.js';
import * as action_specs from '$lib/action_specs.js';
import {is_action_spec} from '$lib/action_spec.js';
import {Action_Registry} from '$lib/action_registry.js';

// TODO some of these can probably be declared differently without codegen

/**
 * Outputs a file with generated types and schemas using the action specs as the source of truth.
 */
export const gen: Gen = ({origin_path}) => {
	const registry = new Action_Registry(
		Object.values(action_specs).filter((s) => is_action_spec(s)),
	);

	const banner = `generated by ${origin_path} - DO NOT EDIT OR RISK LOST DATA`;

	return `
		// ${banner}

		import {z} from 'zod';
		import type {Result} from '@ryanatkn/belt/result.js';

		import type {Action_Inputs, Action_Outputs} from '$lib/action_collections.js';
		import type {Jsonrpc_Error_Json} from '$lib/jsonrpc.js';

		/**
		 * All action method names. Request/response actions have two types per method.
		 */
		export const Action_Method = z.enum([
			${registry.specs.map(({method}) => `'${method}'`).join(',\n\t')}
		]);
		export type Action_Method = z.infer<typeof Action_Method>;

		/**
		 * Names of all request_response actions.
		 */
		export const Request_Response_Action_Method = z.enum([${registry.request_response_specs
			.map((spec) => `'${spec.method}'`)
			.join(',\n\t')}]);
		export type Request_Response_Action_Method = z.infer<typeof Request_Response_Action_Method>;

		/**
		 * Names of all remote_notification actions.
		 */
		export const Remote_Notification_Action_Method = z.enum([${registry.remote_notification_specs
			.map((spec) => `'${spec.method}'`)
			.join(',\n\t')}]);
		export type Remote_Notification_Action_Method = z.infer<typeof Remote_Notification_Action_Method>;

		/**
		 * Names of all local_call actions.
		 */
		export const Local_Call_Action_Method = z.enum([${registry.local_call_specs
			.map((spec) => `'${spec.method}'`)
			.join(',\n\t')}]);
		export type Local_Call_Action_Method = z.infer<typeof Local_Call_Action_Method>;

		/**
		 * Names of all actions that may be handled on the client.
		 */
		export const Frontend_Action_Method = z.enum([${registry.frontend_methods
			.map((method) => `'${method}'`)
			.join(',\n\t')}]);
		export type Frontend_Action_Method = z.infer<typeof Frontend_Action_Method>;

		/**
		 * Names of all actions that may be handled on the server.
		 */
		export const Backend_Action_Method = z.enum([${registry.backend_methods
			.map((method) => `'${method}'`)
			.join(',\n\t')}]);
		export type Backend_Action_Method = z.infer<typeof Backend_Action_Method>;

		/**
		 * Interface for action dispatch functions.
		 * All async methods return Result types for type-safe error handling.
		 * Sync methods (like toggle_main_menu) return values directly.
		 */
		export interface Actions_Api {
			${registry.specs
				.map((spec) => {
					const innermost_type_name = get_innermost_type_name(spec.input);
					const has_input = innermost_type_name !== 'null' && innermost_type_name !== 'void';
					const is_async = spec.kind === 'request_response' || spec.async;
					const return_type = is_async
						? `Promise<Result<{value: Action_Outputs['${spec.method}']}, {error: Jsonrpc_Error_Json}>>`
						: `Action_Outputs['${spec.method}']`; // Sync method returns value directly
					return `${spec.method}: (${
						has_input
							? `input${spec.input.safeParse(undefined).success ? '?' : ''}: Action_Inputs['${spec.method}']`
							: 'input?: void'
					}) => ${return_type};`;
				})
				.join('\n\t')}
		}

		// ${banner}
	`;
};
