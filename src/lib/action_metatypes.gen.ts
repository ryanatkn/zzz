import type {Gen} from '@ryanatkn/gro/gen.js';
import {z} from 'zod';

import {get_innermost_type_name} from '$lib/zod_helpers.js';
import * as action_specs from '$lib/action_specs.js';
import {is_action_spec} from '$lib/action_spec.js';
import {Action_Registry} from '$lib/action_registry.js';

/**
 * Outputs a file with generated types and schemas using the action specs as the source of truth.
 */
export const gen: Gen = ({origin_path}) => {
	const registry = new Action_Registry(
		Object.values(action_specs).filter((s) => is_action_spec(s)),
	);

	const banner = `generated by ${origin_path} - DO NOT EDIT OR RISK LOST DATA`;

	return `
		// ${banner}

		import {z} from 'zod';

		import type {Action_Inputs, Action_Outputs} from '$lib/action_collections.js';

		/**
		 * All action method names. Request/response actions have two types per method.
		 */
		export const Action_Method = z.enum([
			${registry.specs.map(({method}) => `'${method}'`).join(',\n\t')}
		]);
		export type Action_Method = z.infer<typeof Action_Method>;

		/**
		 * Names of all request_response actions.
		 */
		export const Request_Response_Action_Method = z.enum([${registry.request_response_specs
			.map((spec) => `'${spec.method}'`)
			.join(',\n\t')}]);
		export type Request_Response_Action_Method = z.infer<typeof Request_Response_Action_Method>;

		/**
		 * Names of all remote_notification actions.
		 */
		export const Remote_Notification_Action_Method = z.enum([${registry.remote_notification_specs
			.map((spec) => `'${spec.method}'`)
			.join(',\n\t')}]);
		export type Remote_Notification_Action_Method = z.infer<typeof Remote_Notification_Action_Method>;

		/**
		 * Names of all local_call actions.
		 */
		export const Local_Call_Action_Method = z.enum([${registry.local_call_specs
			.map((spec) => `'${spec.method}'`)
			.join(',\n\t')}]);
		export type Local_Call_Action_Method = z.infer<typeof Local_Call_Action_Method>;

		/**
		 * Names of all actions that may be handled on the client.
		 */
		export const Frontend_Action_Method = z.enum([${registry.frontend_methods
			.map((method) => `'${method}'`)
			.join(',\n\t')}]);
		export type Frontend_Action_Method = z.infer<typeof Frontend_Action_Method>;

		/**
		 * Names of all actions that may be handled on the server.
		 */
		export const Backend_Action_Method = z.enum([${registry.backend_methods
			.map((method) => `'${method}'`)
			.join(',\n\t')}]);
		export type Backend_Action_Method = z.infer<typeof Backend_Action_Method>;

		/**
		 * Interface for action dispatch functions.
		 */
		export interface Actions_Api {
			${registry.specs
				.map((spec) => {
					const innermost_type_name = get_innermost_type_name(spec.input);
					const has_input =
						innermost_type_name !== z.ZodFirstPartyTypeKind.ZodNull &&
						innermost_type_name !== z.ZodFirstPartyTypeKind.ZodVoid;
					return `${spec.method}: (${
						has_input
							? `input${spec.input.isOptional() ? '?' : ''}: Action_Inputs['${spec.method}']`
							: 'input?: void'
					}) => ${
						spec.kind === 'request_response' || spec.async
							? `Promise<Action_Outputs['${spec.method}']>`
							: `Action_Outputs['${spec.method}']`
					};`;
				})
				.join('\n\t')}
		}

		// ${banner}
	`;
};
